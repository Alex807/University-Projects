		Design Patterns  (vezi slidesPDSS + RefactoringGURU ->java)
(CREATIONALE)
1. Singleton = limiteaza crearea de instante ale clasei

2. Cloning(Prototype) = fie creaza in intregime alt obiect identic/pointer la aceeasi zona de mem

3. Builder pattern = folosim pentru a creea mai usor obiecte si sa nu avem extrem de multe args in constructor

4. Factory Method = folosit pentru a creea instante al subclaselor pe baza unui parametru string TYPE

(STRUCTURALE) 
1. Composite = vrem sa creem obiecte ce contin O COLECTIE<BASE-type> de obiecte pe care executam o actiune(doar obiectul FRUNZA face actiunea propriu zisa, restul delega sarcini)

2. Decorator = creem obiecte ce contin UN OBIECT(de tip BASE) iar cand executam o actiune AMBELE OBIECTE CONTRIBUIE(actiune obiect continut + actiune obiect principal) 

*  Adapter = avem o clasa Adapter ce face call pe obiectul ce nu respecta un tip al interfetei, si IL PRELUCREAZA pentru a ajunge la acel tip

(COMPORTAMENT) 
1. Chain_of_Responsability = contine un atribut de tip BASE(NEXT) si un atribut PROTECTED(succeeded) pe care il apeleaza daca nodul curent nu poate gestiona situatia(next.handle())

2. Command Pattern = folosit pentru a executa mai multe actiuni la apasarea unui BUTON(la butoane-comenzi este folosit de obicei) 

3. Observer = folosit pentru comunicarea intre obiecte atunci cand starea obiectului SUBIECT este modificata(SUBIECT-statieMeteo, Ziar, PostStiri etc; CONCRETE_OBSERVER -> Alex, Mihai (cine e interesat) SUBIECT(cel ce este analizat si anuntati obs)  OBSERVER(cel ce reactioneaza la schimbarea SUB.)
     ! SUBIECTUL contine o lista de observers!

4. Template Method = definim o metoda ce are un schelet COMUN pentru toate subclasele sale(definesti metoda cu ce e comun si partile specifice le pui drept apel catre metode abstracte ce vor fi override in subclase)

5. Strategy Pattern = folosim atunci cand retine o COLECTIE<BASE-type> pe care apelam la fiecare elem o operatie, dar nu trb sa stim exact ce subtip este apelat

6. Visitor = folosim cand vrem sa SEPARAM algoritmul/logica de obiectele pe care lucreaza(fiecare Telefon trebuie sa aiba  acelasi FEATURES ce le poate executa[toate features sa fie suportate de toate TEL), deci nu poate fi particularizat pe un telefon anume) 

7. Acyclic Visitor = decuplam FEATURE de TELEFON si astfel pot fi  particularizate fiecare TEL ce stie sa faca(facem o INTERFATA-BASE urmata de INTERFETE pentru FIECARE FEATURE) ->trebuie ca metodele sa primeasca acel obiect, vezi cod Digital-Ocean la VISITOR


   !!!DACA ai nevoie vezi DIGITAL-OCEAN / Geeks diagrame despre DP necesar !!!!

      (Principii-SOLID) 
1. Single Responsability
2. Open-Close  
3. Liskow Substitution 
4. Interface Segregation 
5. Dependency Inversion 